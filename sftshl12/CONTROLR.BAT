@ECHO OFF
REM
REM ** THIS PROGRAM DEMONSTRATES THE ABILITY TO CONTROL ANOTHER **
REM ** USING SFTShell'S BATCH LANGUAGE AND LANGUAGE EXTENSIONS. **
REM **    updated 9/24/95 to accomodate Windows '95 NOTEPAD     **
REM
LET old_text_color=GETTEXTCOLOR()
LET old_bk_color=GETBKCOLOR()
REM
REM set text/background color to YELLOW on BLACK
REM
LET void=SETTEXTCOLOR(11)
LET void=SETBKCOLOR(0)
CLS
SET hdlg=
SET hwnd=
SET hedit=
ECHO.
ECHO.** 'CONTROL' DEMO PROGRAM **
ECHO.
REM
REM set text color to CYAN
REM
LET void=SETTEXTCOLOR(14)
REM
REM ** LOAD THE 'NOTEPAD' APPLICATION AS AN ICONIC WINDOW
REM
LH NOTEPAD
IF NOT (CMD_ERROR) GOTO OK_SO_FAR
ECHO.
ECHO.** Could not start NOTEPAD application **
ECHO.
GOTO THE_END
REM
:OK_SO_FAR
REM
REM ** SAVE THE TASK ID ASSOCIATED WITH THE APPLICATION WE LOADED
REM
LET htask=TASK_ID
;
;* update 9/24/95 - Windows '95 needs a couple of re-tries
;
FOR ctr0 FROM 1 to 5
REM
REM ** GET THE 'MAIN' WINDOW FOR THIS TASK ('NOTEPAD' CLASS) BY LOOKING
REM ** AT ALL OF THE WINDOWS FOR THE TASK ID USING 'GETWINDOW()' UNTIL
REM ** WE FIND ONE THAT HAS A CLASS NAME 'NOTEPAD'.
REM
LET void=PAUSE(1000)
;
;* wait 1 second per iteration for Windows '95 version of NOTEPAD to initialize *
;
LET ctr=0
:LOOP1
REM
REM ** GET WINDOW INFORMATION FOR THIS 'ITERATION' COUNT
REM
LET a=GETWINDOW(htask,ctr)
REM
;IF (LEN(a)=0) GOTO LOOP1_BAILOUT
IF (LEN(a)=0) CONTINUE
IF (UPPER(a[7])=="NOTEPAD") GOTO LOOP1_END
REM
LET ctr=ctr+1
GOTO LOOP1
REM
NEXT ctr0
; flow through to 'bailout' part below
:LOOP1_BAILOUT
REM
REM ** COULD NOT FIND 'MAIN' WINDOW FOR 'NOTEPAD' APPLICATION
REM
ECHO.
ECHO.** could not find top-level window for NOTEPAD! **
ECHO.
CLOSETASK %htask%
GOTO THE_END
REM
:LOOP1_END
REM
REM ** 'a' NOW CONTAINS THE INFORMATION ABOUT THE 'MAIN' WINDOW
REM ** ASSIGN THE WINDOW HANDLE TO A VARIABLE 'hwnd'
REM
LET hwnd=a[0]
REM
REM ** BEFORE I SELECT ANY MENU ITEMS, SET FOCUS TO THIS WINDOW
REM
LET void=SHOWWINDOW(hwnd,9)
REM
REM ** SEND THE KEYSTROKES FOR 'ALT-F' 'O' TO THE WINDOW.  NOTICE THAT
REM ** FOR MENU SELECTIONS I ABSOLUTELY MUST SEND 'VIRTUAL' KEY MESSAGES
REM
LET void=SENDVIRTUALKEY(hwnd,ASC("F"),4)
REM
LET void=SENDVIRTUALKEY(hwnd,ASC("O"),0)
REM
REM ** ESTABLISH A RETRY LOOP FOR FINDING THE 'OPEN' DIALOG BOX THAT I
REM ** AM ABOUT TO CREATE.  THE CLASS NAME IS '#32770' (THIS CAN BE
REM ** DETERMINED BY EXPERIMENTATION OR USE OF DIAGNOSTIC SOFTWARE),
REM ** AND THE WINDOW TITLE IS 'OPEN'.
REM
LET ctr1=0
:LOOP2a
REM
REM ** USE A .2 SEC PAUSE PERIOD TO ALLOW THE 'NOTEPAD' APPLICATION SOME
REM ** CPU TIME TO CREATE THE DIALOG BOX (BUT NOT TOO MUCH!).
REM
LET void=PAUSE(200)
LET ctr=0
REM
REM ** AGAIN, STEP THROUGH ALL OF THE WINDOWS UNTIL WE FIND ONE THAT HAS
REM ** THE CORRECT CLASS NAME ('#32770') *AND* WINDOW TITLE ('OPEN').
REM
:LOOP2
REM
LET a=GETWINDOW(htask,ctr)
REM
IF (LEN(a)=0) GOTO LOOP2_BAIL
IF (UPPER(a[7])=="#32770" AND UPPER(a[1])=="OPEN") GOTO LOOP2_END
REM
LET ctr=ctr+1
GOTO LOOP2
REM
:LOOP2_BAIL
REM
REM ** AT THIS POINT NO MATCH WAS FOUND.  SINCE IT IS POSSIBLE THAT THIS
REM ** WINDOW WAS NOT YET CREATED, WE PERFORM SEVERAL 'RETRY' PASSES
REM ** UNTIL WE ACTUALLY FIND IT, OR ELSE PERFORM TOO MANY PASSES.  EACH
REM ** PASS INCLUDES THE .2 SEC DELAY (ABOVE) TO ENSURE THE 'NOTEPAD'
REM ** APPLICATION GETS SOME CPU TIME TO CREATE THE DIALOG BOX.
REM
LET ctr1=ctr1+1
IF (ctr1<10) GOTO LOOP2a
REM
REM ** AT THIS POINT THE 'OPEN' DIALOG DID NOT SHOW.  SO, REPORT THE
REM ** ERROR CONDITION, AND KILL THE APPLICATION.
REM
ECHO.
ECHO.** 'OPEN' DIALOG BOX NOT FOUND! **
ECHO.
REM
CLOSETASK htask
REM
GOTO THE_END
REM
:LOOP2_END
REM
REM ** AT THIS POINT, 'a' CONTAINS THE INFORMATION ABOUT THE 'OPEN'
REM ** DIALOG BOX.  PLACE THE WINDOW HANDLE INTO 'hdlg'.
REM
LET hdlg=a[0]
REM
REM ** NEXT, USING THE DIALOG BOX WINDOW HANDLE, LOOK AT ALL OF THE
REM ** 'CHILD' WINDOWS LOCATED WITHIN THE DIALOG BOX UNTIL WE FIND THE
REM ** ONE THAT IS AN 'EDIT' CLASS... THIS ONE WILL BE THE ONE INTO
REM ** WHICH WE CAN TYPE A FILE NAME.  ONCE WE HAVE THIS WINDOW HANDLE
REM ** WE CAN FORCE THE KEYSTROKES FOR THE DESIRED FILE NAME INTO IT.
REM
LET void=PAUSE(200)
LET ctr=0
REM
:LOOP3
REM
REM ** THIS TIME, USE 'GETCHILDWINDOW()' WHICH OBTAINS 'CHILD'
REM ** WINDOWS (i.e. windows that are located within another window,
REM ** such as the controls on a dialog box, or 'sub-windows' within
REM ** an 'MDI' application, like PROGRAM MANAGER).
REM
LET a=GETCHILDWINDOW(hdlg,ctr)
REM
IF (LEN(a)=0) GOTO LOOP3_BAIL
IF (UPPER(a[7])=="EDIT") GOTO LOOP3_END
REM
LET ctr=ctr+1
GOTO LOOP3
REM
:LOOP3_BAIL
ECHO.
ECHO.** COULD NOT FIND THE 'EDIT' CONTROL **
ECHO.
REM
CLOSETASK htask
REM
GOTO THE_END
:LOOP3_END
REM
REM ** AT THIS POINT, 'a' CONTAINS THE INFORMATION ON THE 'EDIT' CONTROL
REM ** LOCATED ON THE 'OPEN' DIALOG BOX.  SAVE THE WINDOW HANDLE INTO
REM ** THE 'hedit' ENVIRONMENT VARIABLE.
REM
LET hedit=a[0]
REM
REM ** NOW, JUST TO SHOW THAT IT CAN BE DONE, I SHALL *HIDE* THE SFTShell
REM ** MAIN WINDOW DURING THE NEXT PROCESS.
REM
LET void=SHOWWINDOW(0)
REM
REM ** FORCE KEYSTROKES TO THE 'EDIT' WINDOW! **
REM ** TO AVOID VIRTUAL KEY TRANSLATION PROBLEMS, FIRST SET FOCUS TO
REM ** DIALOG's 'EDIT' CONTROL, THEN TO THE DIALOG ITSELF!  NEXT, SEND
REM ** ALL OF THE VIRTUAL KEYS FOR CURSOR MOTION AND SELECTION TO THE
REM ** DIALOG BOX (they get passed to the control properly this way)
REM
LET void=SHOWWINDOW(hedit,9)
LET void=SHOWWINDOW(hdlg,9)
REM
REM ** CTRL-HOME
REM
LET void=SENDVIRTUALKEY(hdlg,36,2)
REM
REM ** SHIFT-CTRL-END (selects everything in the box!)
REM
LET void=SENDVIRTUALKEY(hdlg,35,3)
REM
REM ** DELETE (this deletes the current text contents)
REM
LET void=SENDVIRTUALKEY(hdlg,46,0)
REM
REM ** INSERT THE TEXT "C:\AUTOEXEC.BAT" (sent to 'EDIT' control)
REM
LET void=SENDKEYS(hedit,"C:\\AUTOEXEC.BAT")
REM
REM ** A QUICK WAY TO PRESS THE 'OK' BUTTON - SEND THE 'ENTER' KEY
REM ** (VIRTUAL KEY 13) TO THE 'EDIT' CONTROL!
REM
LET void=SENDVIRTUALKEY(hedit,13,0)
REM
REM ** THIS NEXT SECTION DISPLAYS WHILE THE WINDOW IS HIDDEN...
REM
ECHO.
ECHO.** THE TASK IS COMPLETE! **
ECHO.
REM
REM ** END OF PROGRAM - DO CLEANUP, DISPLAY WINDOW, ETC.
REM
:THE_END
REM
REM ** DISPLAY THE 'SFTShell' MAIN WINDOW AND GET THE 'FOCUS'
REM
LET a=SHOWWINDOW(9)
REM
REM ** RESTORE SCREEN COLORS TO THE ORIGINAL VALUES
REM
LET void=SETTEXTCOLOR(old_text_color)
LET void=SETBKCOLOR(old_bk_color)
REM
REM ** CLEAR OUT THE VARIABLES WE USED - DONE!
REM
SET old_text_color=
SET old_bk_color=
SET void=
SET a=
SET hdlg=
SET hwnd=
SET hedit=
SET ctr=
