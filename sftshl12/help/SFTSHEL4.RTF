{\rtf1\ansi \deff5\deflang1033{\fonttbl{\f0\froman\fcharset0\fprq2 Tms Rmn;}{\f1\froman\fcharset2\fprq2 Symbol;}{\f2\fswiss\fcharset0\fprq2 Helv;}{\f3\fmodern\fcharset0\fprq1 Courier;}
{\f4\froman\fcharset0\fprq2 Times New Roman;}{\f5\fswiss\fcharset0\fprq2 Arial;}{\f6\froman\fcharset0\fprq2 MS Serif;}{\f7\fswiss\fcharset0\fprq2 MS Sans Serif;}{\f8\froman\fcharset0\fprq2 Times;}{\f9\fswiss\fcharset0\fprq2 Helvetica;}
{\f10\fswiss\fcharset0\fprq2 System;}{\f11\fmodern\fcharset0\fprq1 Courier New;}{\f12\froman\fcharset0\fprq2 New York;}{\f13\fswiss\fcharset0\fprq2 Geneva;}{\f14\fmodern\fcharset0\fprq1 Courier 10cpi;}{\f15\fmodern\fcharset0\fprq1 Courier 12cpi;}
{\f16\fmodern\fcharset0\fprq1 Courier 17cpi;}{\f17\fmodern\fcharset0\fprq1 Courier 20 cpi;}{\f18\fmodern\fcharset0\fprq1 Courier 5cpi;}{\f19\fmodern\fcharset0\fprq1 Courier 6cpi;}{\f20\fmodern\fcharset0\fprq1 Sanserif 10cpi;}
{\f21\fmodern\fcharset0\fprq1 Sanserif 12cpi;}{\f22\fmodern\fcharset0\fprq1 Sanserif 17cpi;}{\f23\fmodern\fcharset0\fprq1 Sanserif 20cpi;}{\f24\fmodern\fcharset0\fprq1 Sanserif 5cpi;}{\f25\fmodern\fcharset0\fprq1 Sanserif 6cpi;}
{\f26\froman\fcharset0\fprq2 Courier PS;}{\f27\froman\fcharset0\fprq2 Sanserif PS;}{\f28\fmodern\fcharset0\fprq1 Orator II 10cpi;}{\f29\fmodern\fcharset0\fprq1 Orator II 12cpi;}{\f30\fmodern\fcharset0\fprq1 Orator II 17cpi;}
{\f31\fmodern\fcharset0\fprq1 Orator II 20cpi;}{\f32\fmodern\fcharset0\fprq1 Orator II 5cpi;}{\f33\fmodern\fcharset0\fprq1 Orator II 6cpi;}{\f34\froman\fcharset0\fprq2 Orator II PS;}{\f35\fmodern\fcharset0\fprq1 Orator I 10cpi;}
{\f36\fmodern\fcharset0\fprq1 Orator I 12cpi;}{\f37\fmodern\fcharset0\fprq1 Orator I 17cpi;}{\f38\fmodern\fcharset0\fprq1 Orator I 20cpi;}{\f39\fmodern\fcharset0\fprq1 Orator I 5cpi;}{\f40\fmodern\fcharset0\fprq1 Orator I 6cpi;}
{\f41\froman\fcharset0\fprq2 Orator I PS;}{\f42\fmodern\fcharset0\fprq1 Fixedsys;}{\f43\fmodern\fcharset255\fprq1 Terminal;}{\f44\fswiss\fcharset0\fprq2 Small Fonts;}{\f45\fmodern\fcharset255\fprq2 Modern;}{\f46\fscript\fcharset255\fprq2 Script;}
{\f47\froman\fcharset255\fprq2 Roman;}{\f48\fmodern\fcharset255\fprq1 SFTShell;}{\f49\fswiss\fcharset0\fprq2 MS Dialog;}{\f50\fswiss\fcharset0\fprq2 MS Dialog Light;}{\f51\fswiss\fcharset0\fprq2 MS SystemEx;}{\f52\fnil\fcharset2\fprq2 Marlett;}
{\f53\fnil\fcharset2\fprq2 Wingdings;}{\f54\fnil\fcharset2\fprq2 Lucida Arrows;}{\f55\fnil\fcharset0\fprq2 Lucida Blackletter;}{\f56\froman\fcharset0\fprq2 Lucida Bright;}{\f57\fnil\fcharset2\fprq2 Lucida Bright Math Extension;}
{\f58\fnil\fcharset2\fprq2 Lucida Bright Math Italic;}{\f59\fnil\fcharset2\fprq2 Lucida Bright Math Symbol;}{\f60\fscript\fcharset0\fprq2 Lucida Calligraphy;}{\f61\fnil\fcharset0\fprq2 Lucida Fax;}{\f62\fscript\fcharset0\fprq2 Lucida Handwriting;}
{\f63\fnil\fcharset2\fprq2 Lucida Icons;}{\f64\fnil\fcharset0\fprq2 Lucida Sans;}{\f65\fmodern\fcharset0\fprq1 Lucida Sans Typewriter;}{\f66\fnil\fcharset2\fprq2 Lucida Stars;}{\f67\fnil\fcharset0\fprq2 Basque Light;}
{\f68\fnil\fcharset0\fprq2 Black Chancery;}{\f69\fnil\fcharset0\fprq2 Chopin;}{\f70\fnil\fcharset0\fprq2 Garamond;}{\f71\fnil\fcharset0\fprq2 Inter;}{\f72\fnil\fcharset0\fprq2 Mapmaker Thin;}{\f73\fnil\fcharset0\fprq2 SaintFrancis;}
{\f74\fmodern\fcharset0\fprq1 Lucida Console;}{\f75\fmodern\fcharset2\fprq1 OCR-A;}{\f76\fmodern\fcharset0\fprq1 QuickType Mono;}{\f77\fswiss\fcharset0\fprq2 QuickType;}{\f78\fswiss\fcharset0\fprq2 QuickType Condensed;}
{\f79\fnil\fcharset2\fprq2 QuickType Pi;}{\f80\fswiss\fcharset0\fprq2 News Gothic MT;}{\f81\fswiss\fcharset0\fprq2 Lucida Sans Unicode;}{\f82\froman\fcharset0\fprq2 Book Antiqua;}{\f83\fmodern\fcharset0\fprq1 OCR A Extended;}
{\f84\froman\fcharset0\fprq2 Calisto MT;}{\f85\fswiss\fcharset0\fprq2 Abadi MT Condensed Light;}{\f86\fswiss\fcharset0\fprq2 Copperplate Gothic Bold;}{\f87\fswiss\fcharset0\fprq2 Copperplate Gothic Light;}{\f88\fscript\fcharset0\fprq2 Comic Sans MS;}
{\f89\fswiss\fcharset0\fprq2 Century Gothic;}{\f90\fswiss\fcharset0\fprq2 Arial Narrow;}{\f91\fnil\fcharset0\fprq2 Arial MT Black;}{\f92\froman\fcharset0\fprq2 Bookman Old Style;}{\f93\froman\fcharset0\fprq2 Century Schoolbook;}
{\f94\fnil\fcharset2\fprq2 Monotype Sorts;}{\f95\fswiss\fcharset0\fprq2 Haettenschweiler;}{\f96\fdecor\fcharset0\fprq2 Algerian;}{\f97\fdecor\fcharset0\fprq2 Braggadocio;}{\f98\fswiss\fcharset0\fprq2 Britannic Bold;}
{\f99\fscript\fcharset0\fprq2 Brush Script MT;}{\f100\fdecor\fcharset0\fprq2 Colonna MT;}{\f101\fdecor\fcharset0\fprq2 Desdemona;}{\f102\froman\fcharset0\fprq2 Footlight MT Light;}{\f103\froman\fcharset0\fprq2 Garamond MT;}
{\f104\fswiss\fcharset0\fprq2 Impact;}{\f105\fdecor\fcharset0\fprq2 Kino MT;}{\f106\froman\fcharset0\fprq2 Wide Latin;}{\f107\fscript\fcharset0\fprq2 Matura MT Script Capitals;}{\f108\fdecor\fcharset0\fprq2 Playbill;}
{\f109\fmodern\fcharset2\fprq1 MS LineDraw;}{\f110\froman\fcharset0\fprq0 symbo;}{\f111\fswiss\fcharset0\fprq0 Chicago;}{\f112\fmodern\fcharset0\fprq0 Monaco;}{\f113\froman\fcharset0\fprq0 Palatino;}
{\f114\fnil\fcharset0\fprq0 BI Letter Gothic BoldSlanted;}{\f115\fnil\fcharset0\fprq0 I Letter Gothic Slanted;}{\f116\fnil\fcharset0\fprq0 CB Helvetica Condensed Bold;}{\f117\fnil\fcharset0\fprq0 CLB Helvetica Condensed Black;}
{\f118\fnil\fcharset0\fprq0 CBI Helvetica Condensed BoldObl;}{\f119\fnil\fcharset0\fprq0 CL Helvetica Condensed Light;}{\f120\fnil\fcharset0\fprq0 CLBI Helvetica Condensed BlackO;}{\f121\fnil\fcharset0\fprq0 CLI Helvetica Condensed LightOb;}
{\f122\fnil\fcharset0\fprq0 Letter Gothic;}{\f123\fnil\fcharset0\fprq0 B Letter Gothic Bold;}{\f124\fnil\fcharset0\fprq0 C Helvetica Condensed;}{\f125\fnil\fcharset0\fprq0 CI Helvetica Condensed Oblique;}{\f126\fnil\fcharset0\fprq0 MT Extra;}
{\f127\fnil\fcharset0\fprq0 MS San Serif;}{\f128\froman\fcharset0\fprq0 ODBCConnectString;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;
\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\li120\sb80\sl-240\slmult0
\widctlpar \f5\fs20 \snext0 Normal;}{\s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \snext26 heading 1;}{\s2\li120\sb120\sa60\sl-240\slmult0\widctlpar \b\f5\fs20\cf2 \snext0 heading 2;}{\s3\li120\sb120\sa60\sl-240\slmult0\widctlpar
\f5\fs20 \snext0 heading 3;}{\s4\fi-245\li360\sb120\sa60\sl-240\slmult0\widctlpar \f5\fs20\cf2 \sbasedon2\snext4 heading 4;}{\s5\li720\sb80\sl-240\slmult0\widctlpar \b\f5\fs20 \sbasedon0\snext17 heading 5;}{\s6\li720\sb80\sl-240\slmult0\widctlpar
\f5\fs20\ul \sbasedon0\snext17 heading 6;}{\s7\li720\sb80\sl-240\slmult0\widctlpar \i\f5\fs20 \sbasedon0\snext17 heading 7;}{\s8\li720\sb80\sl-240\slmult0\widctlpar \i\f5\fs20 \sbasedon0\snext17 heading 8;}{\s9\li720\sb80\sl-240\slmult0\widctlpar
\i\f5\fs20 \sbasedon0\snext17 heading 9;}{\*\cs10 \additive Default Paragraph Font;}{\*\cs15 \additive\f5\fs20\cf2\up6\super \sbasedon10 footnote reference;}{\s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 \sbasedon0\snext0 footnote text;}{
\s17\li720\sb80\sl-240\slmult0\widctlpar \f5\fs20 \sbasedon0\snext0 Normal Indent;}{\s18\fi-240\li600\sb60\sl-240\slmult0\widctlpar \f5\fs20 \snext18 Jli;}{\s19\li120\sb60\sl-240\slmult0\keep\widctlpar\tx520\tx920\tx1320\tx1720\tx2120 \f3\fs16 \snext19
Ex;}{\s20\li360\sb80\sl-240\slmult0\widctlpar \f5\fs20 \snext0 Sa1;}{\s21\fi-240\li360\sl-240\slmult0\widctlpar\tx360 \f5\fs20 \snext22 Lb1;}{\s22\fi-240\li360\sb60\sl-240\slmult0\widctlpar\tx360 \f5\fs20 \snext22 Lb2;}{\s23\li360\sb60\sl-240\slmult0
\widctlpar \f5\fs20 \snext22 Lp1;}{\s24\li115\sb120\sa40\sl-240\slmult0\widctlpar\brdrb\brdrs\brdrw15\brsp20 \brdrbtw\brdrs\brdrw15\brsp20 \b\f5\fs20 \snext25 Th;}{\s25\li115\sb60\sl-240\slmult0\widctlpar \f5\fs20 \snext25 Tp;}{\s26\li120\sl-240\slmult0
\widctlpar \f5\fs20 \snext0 Normal 2;}{\s27\li120\sb120\sa120\widctlpar \f5\fs20 \snext0 bitmap;}{\s28\li120\sb120\sl-240\slmult0\widctlpar \f5\fs20 \snext29 Sa2;}{\s29\fi-240\li360\sb60\sl-240\slmult0\widctlpar \f5\fs20 \snext29 Jl;}{
\s30\li115\sb120\sa40\sl-240\slmult0\widctlpar\brdrb\brdrs\brdrw15\brsp20 \brdrbtw\brdrs\brdrw15\brsp20 \f5\fs20 \sbasedon24\snext25 Th2;}{\s31\li115\sb120\sa40\sl-240\slmult0\widctlpar\brdrb\brdrs\brdrw15\brsp20 \brdrbtw\brdrs\brdrw15\brsp20 \b\f5\fs16
\sbasedon24\snext25 Th3;}{\s32\li115\sb200\sl-240\slmult0\widctlpar \f5\fs20 \sbasedon0\snext0 Normal 3;}{\s33\fi-1800\li1915\sb120\sa40\sl-240\slmult0\widctlpar\brdrb\brdrs\brdrw15\brsp20 \brdrbtw\brdrs\brdrw15\brsp20 \tx1915 \b\f5\fs20
\sbasedon0\snext34 Thh;}{\s34\fi-1800\li1915\sb60\sl-240\slmult0\widctlpar\tx1915 \f5\fs20 \sbasedon0\snext34 Tph;}{\s35\fi-1973\li2088\sl-240\slmult0\widctlpar\tx835\tx1555\tx1915\tx2088\tx2275\tx2995\tx3715 \f5\fs20 \sbasedon26\snext35 Normal 2a;}{
\s36\fi-720\li835\sl-240\slmult0\widctlpar\tx835 \f5\fs20 \sbasedon26\snext36 NOTE;}{\s37\fi-2880\li2995\sl-240\slmult0\widctlpar\tx835\tx1555\tx2995\tx3715\tx4435\tx5155 \f5\fs20 \sbasedon0\snext37 table1;}{\s38\li115\sb80\sl-240\slmult0
\widctlpar\tx835\tx1555\tx2275\tx2995\tx3715\tx4435\tx5155 \f5\fs20\ul \sbasedon0\snext38 tablehead;}{\s39\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 \sbasedon0\snext39 endnote text;}{\*\cs40 \additive\super \sbasedon10 endnote reference;}}{\info
{\author Bob Frazier}{\operator R. E. Frazier}{\creatim\yr1993\mo4\dy29\min51}{\revtim\yr1995\mo9\dy24\hr21\min44}{\version2}{\edmins7}{\nofpages47}{\nofwords7309}{\nofchars41663}{\*\company Stewart~Frazier Tools, Inc.}{\vern57429}}
\widowctrl\ftnbj\aenddoc\ftnnrlc\aftnnar\linkstyles\hyphcaps0 \fet0{\*\template C:\\My Documents\\what31b.dot}\sectd \linex0 {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}
{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}
{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain
\s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} Using ODBC}} {\cs15\fs20\up6\super #{\footnote \pard\plain
\s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} USING_ODBC}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 100}} {\cs15\fs20\up6\super K{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 DisableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`contents')")}} Using ODBC
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 {\uldb Overview of ODBC}{\v ODBC_OVERVIEW}
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\uldb Connecting to an ODBC Driver}{\v ODBC_CONNECT}
\par {\uldb Using Embedded SQL}{\v ODBC_SQL}
\par {\uldb Using Cursors}{\v ODBC_CURSORS}
\par {\uldb Using Transactions}{\v ODBC_TRANSACTIONS}
\par {\uldb Terminating an ODBC Conversation}{\v ODBC_DISCONNECT}
\par {\uldb ODBC Commands}{\v ODBC_COMMANDS}{\uldb
\par ODBC Calculation Functions}{\v functions_ODBC}
\par {\uldb Sample ODBC Program}{\v ODBC_SAMPLE}
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC Overview}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_OVERVIEW}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 101}} {\cs15\fs20\up6\super K
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;Overview}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`USING_ODBC')")}} ODBC Overview
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 Open Database Connectivity (or ODBC) is a standard method for communicating between applications and SQL DBMS systems through an installable driver (provided by the DBMS
 vendor) that translates between ODBC and the native DBMS protocols.  SFTShell provides limited support for many of the ODBC features, enabling you to insert SQL commands into an SFTShell batch program, or move through a table or query 'result set' using
a cursor.
\par The most obvious use of this ODBC in SFTShell is in PROCESS AUTOMATION.  SFTShell provides many other key features that are critical for verifying initial conditions for automated processes, or to determine whether certain processes are even req
uired.  Using the ODBC command set, a data set can be verified or modified through the use of SQL commands or cursors prior to performing some critical operation.  In some cases, SFTShell's ODBC commands may provide all of the needed functionality for a p
articular task.
\par \pard\plain \s3\li120\sb120\sa60\sl-240\slmult0\widctlpar \f5\fs20 {\b\ul ODBC  'Conversation ID'
\par }\pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 An ODBC  conversation normally consists of an {\i Environment Handle}, a {\i Conversation Handle}, and a {\i Statement Handle}
.  SFTShell manages all 3 of these with a unique 'Conversation ID' that is returned from either the ODBC C
ONNECT or ODBC CREATE STATEMENT commands in the 'ODBC_RESULT' environment variable.  This 'Conversation ID' must be included in the command line for each of the ODBC commands that operate on a specific conversation.  To provide for multiple 'statements' (
or instances) for a given ODBC CONNECT command, the ODBC CREATE STATEMENT creates a new {\i Statement Handle} with the same {\i Environment Handle} and {\i Conversation Handle}
, thus enabling you to run multiple SQL queries or cursors on the same connection at the same time.
\par \pard\plain \s3\li120\sb120\sa60\sl-240\slmult0\widctlpar \f5\fs20 {\b\ul ODBC  SQL Queries and Deferred Operations
\par }\pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
ODBC allows an application to perform DEFERRED operations with SQL queries.  ODBC EXECUTE will only start executing the specified SQL query; if the driver supports deferred results, SFTShell's program will continue immediately after the query begins, befo
re any data has been retrieved.  The ODBC FIRST, ODBC NEXT, ODBC PREVIOUS, and ODBC LAST commands can be used to retrieve the data.  Each of these may cause the SFTShell batch program to wait for data to become
available, if there are no additional retrieved records available in the current table or result set.
\par An ODBC SQL BEGIN statement marks the beginning of an embedded SQL program.  'Native SQL' commands are allowed here if the driver supports 'Native SQL'.  All subsequent command lines are assumed to be part of the SQL program until the batch program line c
ontains the "ODBC SQL END" command.  At this point, the SQL program is sent to the driver to be 'prepared'.  If there is an error in preparing the command,
 the ODBC_RESULT' environment variable will contain a value of "ERROR", and the ODBC ERROR command can be used to obtain the actual error text.  Once the SQL program has been prepared, the ODBC EXECUTE command can be used to execute the SQL command.  The
result set is stored in either a temporary 'static' data set, which does not allow updates, or a 'dynaset', which may or may not allow write access to the actual tables involved in the query, depending upon the capabilities of the ODBC driver.  A 'dynaset
' will usually reflect live changes to the table when data is being retrieved, and is required in order to perform updates.  Selection of a static result set or dynaset is automatically performed by SFTShell, based on the capabilities of the ODBC driver.

\par \pard\plain \s3\li120\sb120\sa60\sl-240\slmult0\widctlpar \f5\fs20 {\b\ul Using a Cursor to Read and Write to a Table or DynaSet
\par }\pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 The ODBC OPEN command allows you to open a table directly for read/write access.  A table open with ODBC OPEN allows you to use the various {\i Cursor}
 commands, ODBC FIRST, ODBC NEXT, ODBC PREVIOUS, and ODBC
LAST to navigate through the table.  Each field in a record can be 'bound' to a corresponding environment variable using the ODBC BIND command.  As the cursor is moved, the 'bound' variables will be assigned the corresponding field values from the current
 record in the table.  These variables may be re-assigned as needed by using the SET or LET commands.  The ODBC UPDATE function can then be used to update the current record with the new values.  Also, new records can be added using the ODBC INSERT comman
d.  Any fields in an inserted record which are not bound to an environment variable will receive 'blank' or 'default' values, as assigned by the ODBC driver.  Finally, the ODBC DELETE command can be used to delete the current record from the table.
\par Navigation of a result set is performed in the same manner as with a table.  Following the ODBC EXECUTE command, each {\i Cursor}
 command, ODBC FIRST, ODBC NEXT, ODBC PREVIOUS, and ODBC LAST, allow you to navigate through the result set as though it were a regular table
.  If the ODBC driver supports write operations on a result set, you may also use the ODBC INSERT, ODBC UPDATE, and ODBC DELETE commands.  Typically, writing to a result set will cause the actual tables themselves to be updated, but this behavior is not c
onsistent among all ODBC drivers.  As with OPEN TABLE, each of the fields in a result set must be 'bound' to a corresponding environment variable using the ODBC BIND command.
\par \pard\plain \s3\li120\sb120\sa60\sl-240\slmult0\widctlpar \f5\fs20 {\b\ul Terminating an ODBC Conversation
\par }\pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 Each conversation must be properly terminated whe
n you have finished working with it.  The conversations themselves demand resources from the system, and possibly across a network, depending upon the physical location of the data being accessed by ODBC driver and corresponding DBMS system.  Therefore, t
hey must be properly terminated to ensure that all resources are properly freed, and all updates and transactions have been completed.  Use the ODBC DISCONNECT command to terminate a conversation.  It is important to distinguish that every conversation cr
ea
ted with either ODBC CONNECT or ODBC CREATE STATEMENT must be independently terminated, unless you use ODBC DISCONNECT ALL to terminate all ODBC conversations at once.  Also, a conversation created by ODBC CREATE STATEMENT becomes an independent entity fr
om the conversation it was derived from.  Therefore, terminating one of them has absolutely no effect upon the other.  SFTShell internally manages the various {\i Environment Handles}, {\i Conversation Handles}, and {\i Statement Handles}
 associated with all of its active ODBC conversations.
\par NOTE:  When SFTShell terminates, it will automatically perform an ODBC DISCONNECT operation.  However, it is not preferable to rely upon this.  Use ODBC DISCONNECT or ODBC DISCONNECT ALL to terminate your ODBC conversations.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} Connecting to an ODBC Driver}} {\cs15\fs20\up6\super #
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CONNECT}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 102}} {
\cs15\fs20\up6\super K{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;Connect}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`USING_ODBC')")}} Connecting to an ODBC Driver
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 To connect to an ODBC driver, you must use the ODBC CONNECT command, with the following syntax:
\par \pard\plain \fi240\li120\sb80\sl-240\slmult0\widctlpar\tx360 \f5\fs20 ODBC CONNECT \{connection string\}
\par \pard \li120\sb80\sl-240\slmult0\widctlpar Where \{connection string\} optionally contains one or more of the following, separated by semicolons:
\par \pard\plain \s26\fi240\li120\sl-240\slmult0\widctlpar\tx360 \f5\fs20 DSN=\{data source name\}
\par UID=\{user ID\}
\par PWD=\{password\}
\par DRIVER=\{\{connection info\}\}\tab (NOTE:  '\{\{' and '\}\}' represent literal curly braces)
\par \pard\plain \fi420\li120\sb80\sl-240\slmult0\widctlpar\tx540 \f5\fs20 - or -
\par \pard \fi240\li120\sb80\sl-240\slmult0\widctlpar\tx360 \{driver defined string\}=\{driver defined value\}
\par \pard \li120\sb80\sl-240\slmult0\widctlpar
\par Following "ODBC CONNECT", the 'ODBC_RESULT' environment variable will contain the resulting CONNECTION IDENTIFIER, to be passed to all subsequent ODBC commands and functions that apply to this ODBC connection.  On error, 'ODBC_RESULT' contains the string
"ERROR".
\par A typical connection command might appear as follows:
\par \pard \fi240\li120\sb80\sl-240\slmult0\widctlpar\tx360 ODBC CONNECT DSN=DBASE;UID=OWNER;PWD=MASTER
\par \pard \li120\sb80\sl-240\slmult0\widctlpar Any additional parameters which are required but not specified will be automatically prompted for by the driver.  A dialog box specific to the ODBC driver will appear, asking for the needed information.
\par If you wish to have the ODBC drivers prompt for all information, including a list of all possible ODBC data sources that have been installed on your system, simply use 'ODBC CONNECT' without any additional parameters.  After the connection has been establ
ished, the 'ODBCConnectString()' function will return the fully qualified connection string as returned by the driver itself.   The following is a typical use of 'ODBC CONNECT' to prompt for all parameter
s, and for 'ODBCConnectString()' to return the actual connect string:
\par \pard \fi240\li120\sb80\sl-240\slmult0\widctlpar ODBC CONNECT
\par IF %ODBC_RESULT%==%ERROR% GOTO WAS_ERROR
\par LET my_connect=ODBC_RESULT
\par LET my_connect_str=ODBCConnectString(my_connect)
\par \pard \li120\sb80\sl-240\slmult0\widctlpar
Although the 'DSN', 'UID', and 'PWD' parameters are ODBC standards, not all ODBC drivers will necessarily use them, though you can usually expect 'DSN' to be used.  You might also see driver-specific parameters used, depending upon the needs of the driver
.  If you need to obtain all of the required parameters f
or future reference, you can examine the results returned by the 'ODBCConnectString()' function after a connection has been successfully made.  As an example, you can enter the following commands from the command line:
\par \pard \fi240\li120\sb80\sl-240\slmult0\widctlpar\tx360 ODBC CONNECT
\par \pard \li120\sb80\sl-240\slmult0\widctlpar \{the ODBC driver prompts you for a data source and other information\}
\par \pard \fi240\li120\sb80\sl-240\slmult0\widctlpar LET x=ODBC_RESULT
\par CALC ODBCConnectString(x)
\par \pard \li120\sb80\sl-240\slmult0\widctlpar \{SFTShell prints the connect string\}
\par \pard \fi240\li120\sb80\sl-240\slmult0\widctlpar\tx360 ODBC DISCONNECT %x%
\par \pard \li120\sb80\sl-240\slmult0\widctlpar \{The ODBC connection is closed\}
\par At this point, you can record the actual 'connect string' used to establish the ODBC connection, and place it directly into a program, as follows:
\par \pard \fi240\li120\sb80\sl-240\slmult0\widctlpar ODBC CONNECT DSN=Access_sdk20;DBQ=c:\\odbc\\sample.mdb;FIL=REDISAM;
\par IF %ODBC_RESULT%==ERROR GOTO WAS_ERROR
\par LET AccessConnect=ODBC_RESULT
\par \pard \li120\sb80\sl-240\slmult0\widctlpar If the connection also contains user and logon information, you can always exclude these elements from the connect string to allow the driver to prompt for them.
\par
\par Once a connection has been made, you can create additional 'statements' (or instances) of the same connection with the 'ODBC CREATE STATEMENT' c
ommand.  This is a convenient method by which you can open multiple tables, views, or 'DynaSets' from within the same driver connection.  The advantage to using 'ODBC CREATE STATEMENT' is that the same connection string will automatically apply to each ad
ditional 'CONNECTION IDENTIFIER' it creates, and the driver will never prompt you for any additional connection information.  For example:
\par \pard \fi240\li120\sb80\sl-240\slmult0\widctlpar ODBC CONNECT DSN=MyDriver
\par LET mydriver1=ODBC_RESULT
\par ODBC CREATE STATEMENT %mydriver1%
\par LET mydriver2=ODBC_RESULT
\par \pard \li120\sb80\sl-240\slmult0\widctlpar
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} Using Embedded SQL}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_SQL}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 103}} {\cs15\fs20\up6\super K
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;SQL}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`USING_ODBC')")}} Using Embedded SQL
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20
Once you have established a connection, you need to create an SQL 'SELECT' statement to gain access to a TABLE, a VIEW, or result set.  This requires the use of EMBEDDED SQL statements within your program.  To facilitate this, SFTShell provides 3 basic me
thods.
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
The first method is the simplest, and requires no SQL code at all.  It allows you to open a single table for read/write access (depending upon the user access level and ODBC driver capabilities).  The command syntax is as follows:
\par \pard \fi240\li120\sb80\sl-240\slmult0\widctlpar\tx360 ODBC OPEN [connection ID] TABLENAME
\par \pard \li120\sb80\sl-240\slmult0\widctlpar
where [connection ID] is the 'ODBC_RESULT' value obtained from an ODBC CONNECT or ODBC CREATE STATEMENT command, and TABLENAME is the name of a table that can be accessed by the driver connection.  This command internally creates and executes a
simple SQL query to select all fields for the given table.  This command may be used both from the command line, and from within a batch file.
\par The second method is much like the first, but allows you to specify the actual SQL query string on the command line, as follows:
\par \pard \fi240\li120\sb80\sl-240\slmult0\widctlpar\tx360 ODBC SQL [connection ID] \{SQL Query\}
\par \pard \li120\sb80\sl-240\slmult0\widctlpar where [connection ID] is the 'ODBC_RESULT' value obtained from an ODBC CONNECT or ODBC CREATE STATEMENT command, and \{SQL Query\} is a valid SQL query string.  This command may be used both from the comma
nd line, and from within a batch file.  It's limitations, though, prevent you from easily creating large field selections or 'WHERE' clauses.
\par For added flexibility and readability of 'batch file' programs, there is a third method by which you can use embedded SQL queries.  It also uses the 'ODBC SQL' command, but the '\{SQL Query\}
' string is left blank.  Each line following the 'ODBC SQL' command is then treated as a line of SQL code, the end of which is marked by the 'ODBC SQL END' command.  For example:
\par \pard \fi240\li120\sb80\sl-240\slmult0\widctlpar ODBC SQL %my_connection%
\par \pard\plain \s26\fi240\li120\sl-240\slmult0\widctlpar \f5\fs20 SELECT Product, Customer, SUM(Revenue) As RevSum, ShipDate
\par FROM Shipment
\par ORDER BY Product, ShipDate
\par ODBC SQL END
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
When a new SQL program has been prepared via 'ODBC SQL' (in either of the above two command forms) any existing table, view, or result set is immediately closed.  No data set will be created until an ODBC EXECUTE command is entered from the command line o
r executed within the 'batch file' program.  This differs significantly from 'ODBC OPEN', which automatically performs the 'ODBC EXECUTE' for you.
\par In addition to 'SELECT' queries, other SQL commands that are supported by the driver may be included in embedded SQL statements.  However, some of these do not create a 'result set'.  These commands still require the use of 'ODBC EXECUTE' to begin executi
on.  Further, any active 'result set' will be closed whenever an 'ODBC OPEN' or 'ODBC SQL' command has been entered from the command line or executed in a 'batch file' program.  If you need to have multiple tables or 'result sets'
 open, you will need to create additional 'statements' (on the same connection) or additional driver connections using the 'ODBC CONNECT' and/or 'ODBC CREATE STATEMENT' commands.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} Using Cursors}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CURSORS}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 104}} {\cs15\fs20\up6\super K
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;CURSORS}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`USING_ODBC')")}} Using Cursors
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 Whenever you open a table or query using the 'ODBC OPEN' or 'ODBC SQL' commands, the result set is made ava
ilable to you from the ODBC driver.  The 'ODBC FIRST', 'ODBC NEXT', 'ODBC PREVIOUS', and 'ODBC LAST' commands allow you to navigate through this result set.  And, the 'ODBC UPDATE', 'ODBC DELETE', and 'ODBC INSERT' commands allow you to modify, delete, an
d add new records to the database (as allowed by the driver and query type).
\par
\par In some cases it may be desirable to \ldblquote bind\rdblquote  certain columns to environment variables within SFTShell. 'ODBC INSERT' and 'ODBC UPDATE' both require such \ldblquote bound columns\rdblquote  to pre-assi
gn the column values before adding the new record to the table or updating the column values.  By using the 'ODBC BIND' command, you can \ldblquote bind\rdblquote
 environment variables to the desired columns; this way, a change in one is automatically reflected in the other
.  Following an 'ODBC UPDATE' or 'ODBC INSERT' command, the current value of the bound environment variable is copied to its associated column prior to updating or inserting the record.  And, following a command that moves the cursor (such as 'ODBC NEXT')
 the values of the bound columns are automatically copied to their associated environment variables.
\par
\par At any time you can obtain the values for all columns in the result set using the 'ODBCGetData()' function.  The result is returned as an array (delimited by tab characters), in which each column appears in the index corresponding to its position within t
he result set.  The 'ODBCGetColumnInfo()' function returns a 2-dimensional array of columns and column information (such as data type, size, display width, e
tc.), and 'ODBCGetColumnIndex()' returns the index corresponding to a particular named column within the result set.  In SFTShell, the index values are zero-based, as opposed to 1-based (as they are in SQL).  Therefore, a column referred to as '1' in an S
QL query would have an index of '0' within the array returned by 'ODBCGetData()'.
\par
\par Some drivers may have problems with a combination of bound and un-bound columns in the same result set.  If the driver cannot return the value of a column for 'ODBCGetData()'
, the column itself will contain a "blank" value (zero-length string).  It is therefore a good idea to bind ALL columns of a result set that you might be interested in viewing.
\par
\par The following is a short code section that demonstrates how to read and update an ODBC table:
\par
\par \pard \s26\li360\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1260 ODBC CONNECT
\par IF (ODBC_RESULT=="ERROR") GOTO THE_END
\par LET X=ODBC_RESULT
\par ODBC OPEN %X% MyTable
\par IF (ODBC_RESULT=="ERROR")
\par \pard \s26\fi360\li360\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1260 ODBC ERROR %X%
\par ECHO.%RET_STATUS%
\par \pard \s26\li360\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1260 ELSE
\par \pard \s26\fi360\li360\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1260 ODBC BIND %X% MyColumn X1
\par \pard \s26\li360\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1260 ; 'X1' is now bound to 'MyColumn' within 'MyTable'
\par \pard \s26\fi360\li360\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1260 ODBC FIRST %X%
\par WHILE ODBC_RESULT!=="EOF" AND ODBC_RESULT!=="ERROR"
\par \pard \s26\fi360\li720\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1260 ? ODBCGetData(X)
\par \pard \s26\li360\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1260 ; The above function displays ALL columns to the screen (including bound columns)
\par ; NOTE:\tab some ODBC drivers may not return all columns when at least one bound
\par \pard \s26\li360\sl-240\slmult0\widctlpar\tx720\tx1080\tx1260 ;\tab \tab \tab column exists.  Some drivers may not return any columns to the "left"
\par ;\tab \tab \tab of the last bound column.  A blank value is a good indication that one
\par ;\tab \tab \tab or more of these restrictions exist for your ODBC driver.  Watcom SQL's
\par ;\tab \tab \tab ODBC driver is one of those that exhibits this restriction.
\par \pard \s26\fi360\li720\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1260 ? X1
\par LET X1=X1++" Testing"
\par \pard \s26\li360\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1260 ; add the string ' Testing' to the end of 'MyColumn' (in this case, a VARCHAR column)
\par \pard \s26\fi360\li720\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1260 ODBC UPDATE %X%
\par IF (ODBC_RESULT == "ERROR") EXIT LOOP
\par ODBC NEXT %X%
\par \pard \s26\fi360\li360\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1260 WEND
\par IF (ODBC_RESULT=="ERROR")
\par \pard \s26\fi360\li720\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1260 ODBC ERROR %X%
\par ECHO.%ODBC_RESULT%
\par \pard \s26\fi360\li360\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1260 ENDIF
\par \pard \s26\li360\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1260 ENDIF
\par ODBC DISCONNECT %X%
\par :THE_END
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
\par SFTShell also supports ODBC's use of NAMED CURSORS in 'positioned update' and 'positioned delete' statements.  A positioned update or delete is similar to a normal update or delete, except that the claus
e 'WHERE CURRENT OF cursor name' is added at the end of the SQL code, and 'cursor name' is the value returned by 'ODBCGetCursorName'.  You can also force a specific cursor name for the current conversation ID by using 'ODBC CURSOR'.  It is important to po
int out, however, that the ODBC driver itself must support named cursors and positioned update/delete operations in order for this to work.
\par To implement a positioned update or delete, you need to create a separate 'statement' using 'ODBC CREATE STATEMENT',
then use 'ODBC SQL' and 'ODBC EXECUTE' on the desired table with the named cursor from the current statement.  Finally, you must use 'ODBC DROP STATEMENT' to free up the statement ID once it is no longer needed.  An example follows:
\par
\par \pard\plain \s26\li360\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1440 \f5\fs20 ODBC CONNECT
\par IF (ODBC_RESULT=="ERROR") GOTO THE_END
\par LET X=ODBC_RESULT
\par ODBC OPEN %X% MyTable
\par IF (ODBC_RESULT=="ERROR")
\par \pard \s26\fi360\li360\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1440 ODBC ERROR %X%
\par ECHO.%RET_STATUS%
\par \pard \s26\li360\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1440 ELSE
\par \pard \s26\fi360\li360\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1440 ODBC FIRST %X%
\par WHILE ODBC_RESULT!=="EOF" AND ODBC_RESULT!=="ERROR"
\par \pard \s26\fi360\li720\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1440 LET X1=ODBCGetData(X)
\par LET X2=ODBCGetColumnIndex(X,"MyColumn")
\par ;NOTE:  column index is '1-based'
\par LET X3=X1[X2-1]
\par ? X3
\par LET X3=X1++" Testing"
\par LET X4=ODBCGetCursorName(X)
\par ODBC CREATE STATEMENT %X%
\par IF (ODBC_RESULT == "ERROR") EXIT LOOP
\par LET X5=ODBC_RESULT
\par ; This next section contains embedded SQL code
\par ; with string substitution in the appropriate places.
\par ; In this case, 'MyColumn' is character data, which
\par ; requires single quotes around literal values.
\par ODBC SQL %X5%
\par \tab UPDATE MyTable SET MyColumn='%X3%'
\par \tab WHERE CURRENT OF %X4%
\par ODBC SQL END
\par IF (ODBC_RESULT !== "ERROR")
\par \tab ODBC EXECUTE %X5%
\par ELSE
\par \pard \s26\fi360\li1080\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1440 ODBC ERROR %X%
\par ECHO.%ODBC_RESULT%
\par \pard \s26\fi360\li720\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1440 ENDIF
\par LET X6=ODBC_RESULT
\par ; 'X6' will act as a flag, later, so I can exit the loop gracefully
\par ; I am now done with the statement ID, so I should dispose of
\par ; it.  Note that this changes 'ODBC_RESULT', which is why
\par ; I saved its value in 'X6'.
\par ODBC DROP STATEMENT %X5%
\par IF (X6 == "ERROR")
\par \tab EXIT LOOP
\par ENDIF
\par ODBC NEXT %X%
\par \pard \s26\fi360\li360\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1440 WEND
\par IF (ODBC_RESULT=="ERROR")
\par \pard \s26\fi360\li720\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1440 ODBC ERROR %X%
\par ECHO.%ODBC_RESULT%
\par \pard \s26\fi360\li360\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1440 ENDIF
\par \pard \s26\li360\sl-240\slmult0\widctlpar\tx360\tx720\tx1080\tx1440 ENDIF
\par ODBC DISCONNECT %X%
\par :THE_END
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} Using ODBC Transactions}} {\cs15\fs20\up6\super #
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_TRANSACTIONS}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 104a}} {
\cs15\fs20\up6\super K{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;Transactions}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {
\cs15\cf2\up6\super !} EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`USING_ODBC')")}} Using ODBC Transactions
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20
Normally, when you make changes to one or more tables, SFTShell will cause the ODBC driver to make these changes permanent as each command is executed.  However, in some instances, you may wish to be able to "undo" a set of changes, in the event
of an error, or if the user decides to cancel an operation that is in progress.  For this, SFTShell supports "transactions", which group together a set of related changes to one or more tables, and allow you to "undo" all of the changes made thus far with
in the transaction.
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
The ODBC TRANSACT function allows you to manage the ODBC transactions.  For ODBC drivers which support transactions, all of the operations that change the contents of a table are kept on record, but not made permanent until a 'commit' op
eration has been performed.  A transaction in ODBC can be "undone" by performing a 'rollback' operation, or by canceling the transaction altogether.
\par SFTShell performs the transactions at the "connection" level.  Therefore, any statements created using 'ODBC CREATE STATEMENT' will share the same transaction state as the other statements derived from the same ODBC conversation.  Performing a 'rollback'
or 'commit' on any of these statement handles will perform the same operation on all of them.  However, other 'unrelated' statement handles created by 'ODBC CONNECT' will not be affected.
\par A typical transaction set may appear as follows:
\par \pard \li360\sb80\sl-240\slmult0\widctlpar ODBC CONNECT DSN=My Database
\par LET X=ODBC_RESULT
\par ODBC OPEN %X% READWRITE MyTable
\par ODBC BIND %X% X1 FirstColumn
\par ODBC BIND %X% X2 SecondColumn
\par ; Begin the transaction set
\par ODBC TRANSACT %X% BEGIN
\par ODBC FIRST %X%
\par WHILE ODBC_RESULT!=="EOF" AND ODBC_RESULT!=="ERROR"
\par   ; in this case, add a '0' to the end of the 'FirstColumn' and 'SecondColumn' fields
\par   LET X1=X1++"0"
\par   LET X2=X2++"0"
\par   ODBC UPDATE %X%
\par   IF (ODBC_RESULT=="ERROR") EXIT LOOP
\par   ODBC NEXT %X%
\par WEND
\par ; at this point, no changes have been written.  If an error took place, I'll want to cancel the whole
\par ; transaction; otherwise, let it go.
\par IF (ODBC_RESULT=="ERROR")
\par   ; cancel all changes thus far
\par   ODBC TRANSACT %X% ROLLBACK
\par ENDIF
\par ;
\par ;** additional operations go here
\par ;
\par ODBC TRANSACT %X% END
\par \pard \li120\sb80\sl-240\slmult0\widctlpar
\par Once I have called 'ODBC TRANSACT END' a 'commit' instruction will be sent to the ODBC driver to force all changes within this transaction to
be permanently written to the respective tables.  If a 'rollback' operation is performed via 'ODBC TRANSACT ROLLBACK', all operations up to that point are "undone", but any operations following the 'rollback' will be written following 'ODBC TRANSACT END'.

\par In some cases you may wish to combine the effect of 'ODBC TRANSACT ROLLBACK' and 'ODBC TRANSACT END'.  For this, a single command may be used: 'ODBC TRANSACT CANCEL'.  The 'CANCEL' option performs the equivalent of these two statements in a single stateme
nt, and is provided for convenience.
\par Since ODBC transactions in SFTShell are defined as a set of commands within an 'ODBC TRANSACT BEGIN' and 'ODBC TRANSACT END' (or 'ODBC TRANSACT CANCEL') statement, there is no separate command to perform a 'commit' operation other than 'ODBC TRANSACT END'
.  Therefore, for each transaction 'commit'  you must use 'ODBC TRANSACT BEGIN' to start another transaction.  As an example:
\par \pard \li360\sb80\sl-240\slmult0\widctlpar ODBC TRANSACT %X% BEGIN
\par ; perform a bunch of changes to table(s)
\par ODBC TRANSACT %X% END
\par ODBC TRANSACT %X% BEGIN
\par ; perform more changes to table(s)
\par ODBC TRANSACT %X% END
\par ;
\par ; Etc. Etc. Etc.
\par
\par \pard \li120\sb80\sl-240\slmult0\widctlpar
When a statement is 'dropped' or an ODBC conversation 'disconnected' via 'ODBC DROP STATEMENT' or 'ODBC DISCONNECT' a 'CANCEL' is automatically performed for any pending transactions.  You should therefore make sure that 'ODBC TRANSACT END' is called prio
r to 'dropping' a statement or 'disconnecting' the ODBC conversation.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} Terminating an ODBC Conversation}} {
\cs15\fs20\up6\super #{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_DISCONNECT}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +
} 105}} {\cs15\fs20\up6\super K{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;Disconnect}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {
\cs15\cf2\up6\super !} EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`USING_ODBC')")}} Terminating an ODBC Conversation
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20
To terminate an ODBC Conversation, you can either use the "ODBC DISCONNECT" command, or "ODBC DISCONNECT ALL" command.  For "ODBC DISCONNECT" you must specify which conversation you are disconnecting, as follows:
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 \tab ODBC DISCONNECT %X%
\par where 'X' contains the 'CONVERSATION IDENTIFIER' returned by "ODBC CONNECT".
\par
\par If the 'CONVERSATION IDENTIFIER' was created using "ODBC CREATE STATEMENT", you should use the "ODBC DROP STATEMENT" command to close it, as follows:
\par \tab ODBC DROP STATEMENT %X%
\par
\par When an ODBC conversation is closed, any pending transactions are canceled.  If you wish to ensure that all transactions have completed, you must use "ODBC TRANSACT END" to force a 'commit' for any pending transactions, prior to calling "ODBC DISCONNECT"
or "ODBC DROP STATEMENT".
\par
\par In any case, "ODBC DISCONNECT ALL" automatically closes all conversations, and invalidates all 'CONVERSATION IDENTIFIERS', no matter how they were created.
\par
\par NOTE:  When SFTShell terminates, an implicit "ODBC DISCONNECT ALL" is performed to ensure that all ODBC conversations are closed prior to terminating SFTShell.  However, any "Batch Programs" you write should not rely upon this, but rather should close any
 ODBC conversations it creates prior to exiting.
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC Command Options}} {\cs15\fs20\up6\super #
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_COMMANDS}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106}} {
\cs15\fs20\up6\super K{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`USING_ODBC')")}} ODBC Command Options
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 The following is a list of the various command options associated with the ODBC command.
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
\par {\b\ul\cf2 Conversations and Statements}{\ul
\par }{\uldb ODBC CONNECT}{\v ODBC_CMD_CONNECT}
\par {\uldb ODBC DISCONNECT}{\v ODBC_CMD_DISCONNECT}
\par {\uldb ODBC CREATE STATEMENT}{\v ODBC_CMD_CREATE_STATEMENT}
\par {\uldb ODBC DROP STATEMENT}{\v ODBC_CMD_DROP_STATEMENT}
\par {\uldb ODBC ERROR}{\v ODBC_CMD_ERROR}
\par
\par {\b\ul\cf2 SQL Commands and Tables}{\ul
\par }{\uldb ODBC SQL}{\v ODBC_CMD_SQL}
\par {\uldb ODBC OPEN}{\v ODBC_CMD_OPEN}
\par {\uldb ODBC EXECUTE}{\v ODBC_CMD_EXECUTE}
\par {\uldb ODBC CANCEL}{\v ODBC_CMD_CANCEL}
\par
\par {\b\ul\cf2 Cursor Control}{\ul
\par }{\uldb ODBC BIND}{\v ODBC_CMD_BIND}{\uldb
\par ODBC CURSOR}{\v ODBC_CMD_CURSOR}
\par {\uldb ODBC FIRST}{\v ODBC_CMD_FIRST}
\par {\uldb ODBC LAST}{\v ODBC_CMD_LAST}{\uldb
\par ODBC NEXT}{\v ODBC_CMD_NEXT}
\par {\uldb ODBC PREVIOUS}{\v ODBC_CMD_PREVIOUS}
\par
\par {\b\ul\cf2 Modifying the Current Result Set}{\ul
\par }{\uldb ODBC DELETE}{\v ODBC_CMD_DELETE}
\par {\uldb ODBC INSERT}{\v ODBC_CMD_INSERT}
\par {\uldb ODBC UPDATE}{\v ODBC_CMD_UPDATE}
\par {\uldb ODBC TRANSACT}{\v ODBC_CMD_TRANSACT}
\par
\par See Also:  {\uldb ODBC Command (Summary)}{\v CMD_ODBC}
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC CONNECT}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_CONNECT}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106a}} {\cs15\fs20\up6\super K
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;CONNECT}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC CONNECT
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC CONNECT [{\i connect string}]
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
This command creates a unique 'conversation ID' for an ODBC connection, which can then be subsequently passed to any of the other ODBC commands and functions.  Specifying a 'connect string' on the command line will connect to a specific ODBC driver using
that connection string.  Otherwise, the user will be given a choice of ODBC connections, from which he must chose one.
\par Use '{\uldb ODBC DISCONNECT}{\v ODBC_CMD_DISCONNECT}' to delete conversation ID's created by 'ODBC CONNECT'.
\par On error, the 'ODBC_RESULT' environment variable is set to 'ERROR' and no connection is created.  Otherwise, 'ODBC_RESULT' contains a valid 'conversation ID' that must be assigned to another variable, as 'ODBC_RESULT' can change each time an ODBC command
or function is executed.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC DISCONNECT}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_DISCONNECT}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106b}} {
\cs15\fs20\up6\super K{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;DISCONNECT}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {
\cs15\cf2\up6\super !} EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC DISCONNECT
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC DISCONNECT ALL
\par ODBC DISCONNECT {\i conversation ID}
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
This command disconnects a specific 'conversation ID' for an ODBC connection, or optionally disconnects all 'conversation ID's and invalidates them. Any open transactions or operations in process for this connection will be canceled, and the 'conversation
 ID' will be invalidated and resources freed.
\par On error, the 'ODBC_RESULT' environment variable is set to 'ERROR'.  Otherwise, 'ODBC_RESULT' contains a value of 'OK'.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC CREATE STATEMENT}} {\cs15\fs20\up6\super #
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_CREATE_STATEMENT}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106c}} {
\cs15\fs20\up6\super K{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;CREATE STATEMENT}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {
\cs15\cf2\up6\super !} EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC CREATE STATEMENT
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC CREATE STATEMENT {\i conversation ID}
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 This command creates an additional st
atement for an existing 'conversation ID' that shares the same environment and connection information.  This includes named cursors and transaction states.  This command is very useful in performing positioned update and delete operations, where a named c
ursor from a related 'conversation ID' (one that shares the same environment and connection) is used in a 'WHERE CURRENT OF cursor name' clause within an 'UPDATE' or 'DELETE' SQL statement for a conversation ID created by 'ODBC CREATE STATEMENT'.
\par Use '{\uldb ODBC DROP STATEMENT}{\v ODBC_CMD_DROP_STATEMENT}' to delete conversation ID's created by 'ODBC CREATE STATEMENT'.
\par On error, the 'ODBC_RESULT' environment variable is set to 'ERROR' and no statement is created.  Otherwise, 'ODBC_RESULT' contains a valid 'conversation ID' that must be assigned to another variable, as 'ODBC_RESULT' can change each time an ODBC command o
r function is executed.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC DROP STATEMENT}} {\cs15\fs20\up6\super #
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_DROP_STATEMENT}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106d}} {
\cs15\fs20\up6\super K{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;DROP STATEMENT}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {
\cs15\cf2\up6\super !} EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC DROP STATEMENT
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC DROP STATEMENT {\i conversation ID}
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 This command deletes a specific 'conversation ID' for a statement created by {\uldb ODBC CREATE STATEMENT}{\v ODBC_CMD_CREATE_STATEMENT}
'.  Any open transactions or operations in process for this statement will be canceled, and the 'conversation ID' will be invalidated and resources freed.
\par On error, the 'ODBC_RESULT' environment variable is set to 'ERROR'.  Otherwise, 'ODBC_RESULT' contains a value of 'OK'.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC ERROR}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_ERROR}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106d2}} {\cs15\fs20\up6\super K
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;ERROR}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC ERROR
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC ERROR [{\i conversation ID}]
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
This command obtains error information, optionally about a specific 'conversation ID'.  Any time ODBC_RESULT contains a value of 'error', this command can be called to get information about the error from the ODBC driver.  In some cases, the errors are ge
nerated internally by SFTShell.  'ODBC ERROR' can obtain these as well.
\par On error, the 'ODBC_RESULT' environment variable is set to 'ERROR'.  Otherwise, 'ODBC_RESULT' contains the driver-generated error information, as follows:
\par \pard \fi240\li120\sb80\sl-240\slmult0\widctlpar \{SQL state\} \{error code\} \{error message text\}
\par \pard \fi-870\li990\sb80\sl-240\slmult0\widctlpar\tx270\tx990 WHERE\tab \{SQL state\} represents a valid 'SQL State' code generated by the driver,
\par \tab \tab \{error code\} represents error code generated by the driver,
\par \tab AND\tab \{error message text\} is the driver-specific error message.
\par \pard \li120\sb80\sl-240\slmult0\widctlpar
Each of the 3 elements in 'ODBC_RESULT' are separated by TAB characters, though it is not a true 'array', as the array subscript operator may detect embedded commas within the error message text as array element separators, yielding inconsistent results.

\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC SQL}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_SQL}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106e}} {\cs15\fs20\up6\super K
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;SQL}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC SQL
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC SQL {\i conversation ID }\{SQL command text\}
\par \pard \s26\li120\sl-240\slmult0\widctlpar\tx360 \tab - or -
\par \pard \s26\li120\sl-240\slmult0\widctlpar ODBC SQL {\i conversation ID
\par }\pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 \{SQL command text\}
\par ODBC SQL END
\par This command prepares SQL command for the specified 'conversation ID', but does not execute it. An SQL command can consist of one line only (first form, above), or multiple lines (batch files, second form) terminat
ed by an ODBC SQL END statement as the only command on the line.  To execute the SQL command, use the {\uldb ODBC EXECUTE}{\v ODBC_CMD_EXECUTE} command.
\par On error, the 'ODBC_RESULT' environment variable is set to 'ERROR'.  Otherwise, 'ODBC_RESULT' contains a value of 'OK'.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC OPEN}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_OPEN}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106f}} {\cs15\fs20\up6\super K
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;OPEN}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC OPEN
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC OPEN {\i conversation ID} \{table name\}
\par ODBC OPEN {\i conversation ID} READ \{table name\}
\par ODBC OPEN {\i conversation ID} READWRITE \{table name\}
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
This command opens a single table, optionally for READ or READWRITE access, and makes it available as the result set for the specified 'conversation ID'.  This is functionally equivalent to using the following two statements:
\par \tab ODBC SQL {\i conversation ID} SELECT * FROM \{table name\}
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 \tab ODBC EXECUTE {\i conversation ID}
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 Opening a table for 'READWRITE' access instructs the driver that you wish to perf
orm updates on the table, and access checking is performed at this time to ensure you are able to perform updates.  Opening a table for 'READ' prevents access violations on read-only tables, and will automatically fail any attempt at updating the table's
contents.  Specifying neither 'READ' nor 'READWRITE' opens the table in the default mode, which is 'READWRITE' if the current database access permits updates, or 'READ' if it does not.
\par On error, the 'ODBC_RESULT' environment variable is set to 'ERROR'.  Otherwise, 'ODBC_RESULT' contains a value of 'OK'.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC EXECUTE}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_EXECUTE}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106g}} {\cs15\fs20\up6\super K
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;EXECUTE}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC EXECUTE
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC EXECUTE {\i conversation ID
\par }\pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 This command executes a prepared SQL command for the specified 'conversation ID', from a prior {\uldb ODBC SQL}{\v ODBC_CMD_SQL}
 command.  Execution is ASYNCHRONOUS if the driver supports asynchronous operations; otherwise, batch execution is suspended until the result set has been created.
\par On error, the 'ODBC_RESULT' environment variable is set to 'ERROR'.  Otherwise, 'ODBC_RESULT' contains a value of 'OK'.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC CANCEL}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_CANCEL}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106h}} {\cs15\fs20\up6\super K
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;CANCEL}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC CANCEL
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC CANCEL {\i conversation ID
\par }\pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
This command cancels any pending asynchronous SQL command or transaction for the specified 'conversation ID'.  Use of 'ODBC CANCEL' will cancel operations in a similar manner as 'ODBC DISCONNECT' or 'ODBC DROP STATEMENT', but without invalidating the conv
ersation ID.
\par On error, the 'ODBC_RESULT' environment variable is set to 'ERROR'.  Otherwise, 'ODBC_RESULT' contains a value of 'OK'.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC BIND}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_BIND}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106i}} {\cs15\fs20\up6\super K
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;BIND}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC BIND
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC BIND {\i conversation ID} \{variable\} \{column name\}{\i
\par }\pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
This command "binds" an SFTShell environment variable to a particular column within the result set of the specified conversation ID.  All subsequent cursor motion and 'UPDATE' or 'INSERT' statements will use this variable to store and retrieve the column
data.  The use of 'ODBC BIND' is required when using '{\uldb ODBC INSERT}{\v ODBC_CMD_INSERT}' or '{\uldb ODBC UPDATE}{\v ODBC_CMD_UPDATE}'.
\par With some drivers, a bound column will be rendered "blank" or 'NULL' when using '{\uldb ODBCGetData}{\v function_odbcgetdata}
' to retrieve column data.  Other drivers will render columns to the "left" of the right-most bound column as "blank" or 'NULL' as well.  You should verify the behavior of your driver whenever you are using 'ODBC BIND' and 'ODBCGetData' on the same result
 set.  Therefore, it is recommended that you bind ALL columns that you might need to get the value of, whenever you bind one or more columns in a result set.
\par When 'ODBC SQL' or 'ODBC OPEN' is subsequently executed, all bound columns are automatically cleared ('unbound').  Otherwise, they remain bound as long as the result set remains open.  Also, you can bind columns between a call to 'ODBC SQL' and 'ODBC EXEC
UTE'.
\par On error, the 'ODBC_RESULT' environment variable is set to 'ERROR'.  Otherwise, 'ODBC_RESULT' contains a value of 'OK'.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC CURSOR}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_CURSOR}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106j}} {\cs15\fs20\up6\super K
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;CURSOR}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC CURSOR
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC CURSOR {\i conversation ID} \{cursor name\}{\i
\par }\pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
This command assigns a cursor name to the current conversation ID.  Named cursors can be used in positioned update/delete operations within related statements created by using 'ODBC CREATE STATEMENT' on the current conversation ID (or one already 'related
' to it).
\par Not all ODBC drivers support named cursors.  For more information about using cursors, see {\uldb Using Cursors}{\v ODBC_CURSORS}.
\par On error, the 'ODBC_RESULT' environment variable is set to 'ERROR'.  Otherwise, 'ODBC_RESULT' contains a value of 'OK'.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC FIRST}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_FIRST}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106k}} {\cs15\fs20\up6\super K
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;FIRST}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC FIRST
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC FIRST {\i conversation ID} {\i
\par }\pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
This command moves the cursor to the first record in the result set for the current conversation ID.  If the cursor is not currently on the first record and the ODBC driver does not support multi-directional or absolute cursor positioning, an error will r
esult.  This function is functionally equivalent to 'ODBC NEXT' immediately following an 'ODBC OPEN' or 'ODBC EXECUTE'. For more information about using cursors, see {\uldb Using Cursors}{\v ODBC_CURSORS}.
\par On end of file (no more data), the 'ODBC_RESULT' environment var
iable will contain 'EOF'.  On error, the 'ODBC_RESULT' environment variable is set to 'ERROR'.  Otherwise, 'ODBC_RESULT' contains a value of 'OK'.  You should check for all three of these conditions following a call to 'ODBC FIRST', and dispatch them acco
rdingly.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC LAST}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_LAST}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106l}} {\cs15\fs20\up6\super K
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;LAST}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC LAST
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC LAST {\i conversation ID} {\i
\par }\pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
This command moves the cursor to the last record in the result set for the current conversation ID.  If the ODBC driver does not support multi-directional or absolute cursor positioning, an error will result. For more information about using cursors, see
{\uldb Using Cursors}{\v ODBC_CURSORS}.
\par On end of file (no more data), the 'ODBC_RESULT' environment variable will contain 'EOF'.  On error, the 'ODBC_RESULT' environment variable is set to 'ERROR'.  Otherwise, 'ODBC_RESULT' contains a value of 'OK'.  You should
 check for all three of these conditions following a call to 'ODBC LAST', and dispatch them accordingly.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC NEXT}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_NEXT}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106m}} {\cs15\fs20\up6\super K
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;NEXT}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC NEXT
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC NEXT {\i conversation ID} {\i
\par }\pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 This command moves the cursor to the first record in the result set for the current conversation ID.  For ODBC drivers that do not support multi-direct
ional or absolute cursor positioning, this is the only command that can change the cursor position.  This function is functionally equivalent to 'ODBC FIRST' immediately following an 'ODBC OPEN' or 'ODBC EXECUTE'. For more information about using cursors,
 see {\uldb Using Cursors}{\v ODBC_CURSORS}.
\par On end of file (no more data), the 'ODBC_RESULT' environment variable will contain 'EOF'.  On error, the 'ODBC_RESULT' environment variable is set to 'ERROR'.  Otherwise, 'ODBC_RESULT' contains a value of 'OK'.  You should ch
eck for all three of these conditions following a call to 'ODBC NEXT', and dispatch them accordingly.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC PREVIOUS}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_PREVIOUS}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106n}} {\cs15\fs20\up6\super
K{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;PREVIOUS}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC PREVIOUS
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC PREVIOUS {\i conversation ID} {\i
\par }\pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 This command moves the cursor to the previous record in the result set for the current conversation ID.  If the ODBC driver does not s
upport multi-directional or absolute cursor positioning, an error will result. For more information about using cursors, see {\uldb Using Cursors}{\v ODBC_CURSORS}.
\par On beginning of file (no more data), the 'ODBC_RESULT' environment variable will contain 'EOF'.  On error, the 'ODBC_RESULT' environment variable is set to 'ERROR'.  Otherwise, 'ODBC_RESULT' contains a value of 'OK'.  You should check for all three of the
se conditions following a call to 'ODBC PREVIOUS', and dispatch them accordingly.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC DELETE}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_DELETE}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106o}} {\cs15\fs20\up6\super K
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;DELETE}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC DELETE
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC DELETE {\i conversation ID} {\i
\par }\pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 This command will delete the current record referenced by the result set.  Depending upon the capabilities of the ODBC driver and the type of query specified
, this may result in more than one record being deleted in multiple tables.  For more information about using cursors, see {\uldb Using Cursors}{\v ODBC_CURSORS}.
\par On error, the 'ODBC_RESULT' environment variable is set to 'ERROR'.  Otherwise, 'ODBC_RESULT' contains a value of 'OK'.
\par If a transaction is active, the record will not be permanently deleted until 'ODBC TRANSACTION END' is executed.  Until then, you have the option to un-do the operation using 'ODBC TRANSACTION ROLLBACK' or 'ODBC TRANSACTION CANCEL'.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC INSERT}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_INSERT}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106p}} {\cs15\fs20\up6\super K
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;INSERT}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC INSERT
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC INSERT {\i conversation ID} {\i
\par }\pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
This command will insert a new record into the result set, using the data in variables that have been bound to columns via 'ODBC BIND' as data for the new record.  Columns that have not been bound to variables will be assigned 'default' values as defined
by the ODBC driver and dictionary definition (when applicable).  Depending upon the capabilities of the ODBC driver and the type of query specified, this may result in more than one record being inserted into multiple tables.  For more information about u
sing cursors, see {\uldb Using Cursors}{\v ODBC_CURSORS}.
\par On error, the 'ODBC_RESULT' environment variable is set to 'ERROR'.  Otherwise, 'ODBC_RESULT' contains a value of 'OK'.
\par If a transaction is active, the record will not be permanently deleted until 'ODBC TRANSACTION END' is executed.  Until then, you have the option to un-do the operation using 'ODBC TRANSACTION ROLLBACK' or 'ODBC TRANSACTION CANCEL'.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC UPDATE}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_UPDATE}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106q}} {\cs15\fs20\up6\super K
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;UPDATE}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC UPDATE
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC UPDATE {\i conversation ID} {\i
\par }\pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
This command will replace data within the current record from the result set, using the data in variables that have been bound to columns via 'ODBC BIND' as the new data for the record.  Columns that have not been bound to variables will remain 'as-is'.
Depending upon the capabilities of the ODBC driver and the type of query specified, this may result in more than one record being updated within multiple tables.  For more information about using cursors, see {\uldb Using Cursors}{\v ODBC_CURSORS}.
\par On error, the 'ODBC_RESULT' environment variable is set to 'ERROR'.  Otherwise, 'ODBC_RESULT' contains a value of 'OK'.
\par If a transaction is active, the record will not be permanently deleted until 'ODBC TRANSACTION END' is executed.  Until then, you have the option to un-do the operation using 'ODBC TRANSACTION ROLLBACK' or 'ODBC TRANSACTION CANCEL'.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC TRANSACT}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_CMD_TRANSACT}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 106r}} {\cs15\fs20\up6\super
K{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;commands;TRANSACT}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`ODBC_COMMANDS')")}} ODBC TRANSACT
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 ODBC TRANSACT {\i conversation ID} BEGIN{\i
\par }ODBC TRANSACT {\i conversation ID} END{\i
\par }ODBC TRANSACT {\i conversation ID} ROLLBACK{\i
\par }ODBC TRANSACT {\i conversation ID} CANCEL{\i
\par }\pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
This command allows you to group operations for a conversation ID and its related statements (as created by 'ODBC CREATE STATEMENT') and "commit" them all at the same time, or optionally "roll back" all of the updates performed thus far in case of an erro
r or other condition.  By default, all update
operations "commit" (write to the destination table(s)) at the time the operation is performed.  Using transactions defers writing the changes as 'permanent changes' to the table until the transaction has been completed.  Since a transaction can apply to
more than one statement, you can group several updated tables into a single transaction, helping to ensure database integrity.
\par Not all ODBC drivers support transactions.  For more information about using transactions, see {\uldb Using Transactions}{\v ODBC_TRANSACTIONS}.
\par On error, the 'ODBC_RESULT' environment variable is set to 'ERROR'.  Otherwise, 'ODBC_RESULT' contains a value of 'OK'.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC Functions}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} functions_ODBC}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 107}} {\cs15\fs20\up6\super K
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} functions;ODBC}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super !}
 EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`USING_ODBC')")}} ODBC Functions
\par \pard\plain \fi-2225\li2340\sb80\sl-240\slmult0\widctlpar\tx2340 \f5\fs20 {\uldb ODBCConnectString}{\v function_odbcconnectstring}\tab Get the 'Connect String' for the current ODBC driver{\uldb
\par ODBCGetColumnIndex}{\v function_odbcgetcolumnindex}\tab Returns the index within the array returned by 'ODBCGetData()' that corresponds to a particular column name.
\par {\uldb ODBCGetColumnInfo}{\v function_odbcgetcolumninfo}\tab Returns a 2-dimensional array of information about the columns in the current result set.
\par {\uldb ODBCGetCursorName}{\v function_odbcgetcursorname}\tab Returns the name of the current ODBC cursor (see ODBC CURSOR)
\par {\uldb ODBCGetData}{\v function_odbcgetdata}\tab Obtain the column data for the current result set (single column or all)
\par {\uldb ODBCGetDrivers}{\v function_odbcgetdrivers}\tab Returns an array of ODBC driver names
\par {\uldb ODBCGetInfo}{\v function_odbcgetinfo}\tab Returns selected information about the ODBC Driver via SQLGetInfo()
\par {\uldb ODBCGetTables}{\v function_odbcgettables}\tab Returns an array of table names for the currently open driver
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar\tx2340 \f5\fs20
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBCConnectString}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} function_odbcconnectstring}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 107a}} {
\cs15\fs20\up6\super K{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} functions;ODBC;odbcconnectstring}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {
\cs15\cf2\up6\super !} EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`functions_ODBC ')")}} ODBCConnectString
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 ODBCConnectString(x) - STRING
\par This function returns the ODBC Connect String passed to 'SQLConnect' for the conversation identified by 'x'.  The string is usually of a form similar to "DSN=Data Source", with additional parameters separated by ';' and preceded by a 3-letter identifier a
nd '=', such as "USR=User Name;PWD=Password".  The return value from this function can be subsequently included on the 'ODBC CONNECT' command line to re-connect to the same data source.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBCGetColumnIndex}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} function_odbcgetcolumnindex}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 107b}} {
\cs15\fs20\up6\super K{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} functions;ODBC;odbcgetcolumnindex}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {
\cs15\cf2\up6\super !} EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`functions_ODBC ')")}} ODBCGetColumnIndex
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 ODBCGetColumnIndex(x,y) - NUMERIC
\par This function returns the 1-based index for the given column 'y' within the result set for the conversation identified by 'x'.  The 'y' parameter is a string value that matches the column name in the result set.
\par Column names can be obtained by calling '{\uldb ODBCGetColumnInfo}{\v function_odbcgetcolumninfo}' to enumerate each column index, beginning with one, until the function returns a blank (zero length) string.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBCGetColumnInfo}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} function_odbcgetcolumninfo}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 107c}} {
\cs15\fs20\up6\super K{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} functions;ODBC;odbcgetcolumninfo}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {
\cs15\cf2\up6\super !} EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`functions_ODBC ')")}} ODBCGetColumnInfo
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 ODBCGetColumnInfo(x[,i]) - ARRAY
\par This function returns a 2-dimensional array of information for each column in the result set for the conversation identified by 'x'.  Optionally, it can return information for a single column 'i', where 'i' is a 1-based index in which
 1 is the left-most column in the result set.  Each row in the returned array represents one column in the result set.  Each column within each row contains information about the column in the result set.
\par The array columns for each row consist of the following information:
\par \pard \li120\sb80\sl-240\slmult0\widctlpar\tx1080 {\ul Index}\tab {\ul Description}
\par \pard \fi-960\li1080\sb80\sl-240\slmult0\widctlpar\tqr\tx360\tx1080 \tab 0\tab Column Name - STRING - The actual name of the column.  For unnamed columns, it is a blank (zero length) string.
\par \tab 1\tab Column Label - STRING - The label that is to appear in a heading above the column.  If the column has no label, the column name is returned here.
\par \tab 2\tab Column Type Name - STRING - The data source dependent type name, as a character string, such as 'VARCHAR' or 'FLOAT'.
\par \tab 3\tab Column Length - INTEGER - The physical length of the data stored in the column, in bytes.  For character data, it represents the maximum number of characters.
\par \tab 4\tab Column Precision - INTEGER - The precision of the column.  For numeric data, it is the number of significant digits used after the decimal point when displaying this value.  For character data, it is zero.
\par \tab 5\tab
Column Scale - INTEGER - The 'scale factor' (power of 10) that is used to adjust a numeric value from its internal representation to actual value.  A 'scale factor' can be used with an integer in order to store a fixed-point real value (such as currency).

\par \tab 6\tab Column Display Size - INTEGER - The maximum number of characters needed to properly display the column.  It is used in combination with the Column Precision and Column Scale for numeric data to properly render it on the display.
\par \tab 7\tab Column Type - INTEGER - An integer value that represents the column's SQL data type.  The actual value is one of the 'SQL_' constants as defined in the ODBC SDK, or may be a custom value defined by the ODBC driver.
\par \pard \li1080\sb80\sl-240\slmult0\widctlpar Typical values are as follows:
\par \pard \li1080\sb80\sl-240\slmult0\widctlpar\tx1440 1:\tab SQL_CHAR
\par 2:\tab SQL_NUMERIC
\par 3:\tab SQL_DECIMAL
\par 4:\tab SQL_INTEGER
\par 5:\tab SQL_SMALLINT
\par 6:\tab SQL_FLOAT
\par 7:\tab SQL_REAL
\par 8:\tab SQL_DOUBLE
\par 12:\tab SQL_VARCHAR
\par Other pre-defined values exist, and are considered to be extensions to the ODBC 'core' data types.  Some of these are as follows:
\par 9:\tab SQL_DATE
\par 10:\tab SQL_TIME
\par 11:\tab SQL_TIMESTAMP
\par -1:\tab SQL_LONGVARCHAR
\par -2:\tab SQL_BINARY
\par -3:\tab SQL_VARBINARY
\par -4:\tab SQL_LONGVARBINARY
\par -5:\tab SQL_BIGINT
\par -6:\tab SQL_TINYINT
\par -7:\tab SQL_BIT
\par Other values are considered to be driver-specific.
\par \pard \li120\sb80\sl-240\slmult0\widctlpar
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBCGetCursorName}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} function_odbcgetcursorname}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 107d}} {
\cs15\fs20\up6\super K{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} functions;ODBC;odbcgetcursorname}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {
\cs15\cf2\up6\super !} EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`functions_ODBC ')")}} ODBCGetCursorName
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 ODBCGetCursorName(x) - STRING
\par This function returns the name of the cursor for the conversation identified by 'x'.  This cursor name can be used in positioned updates or deletes, such as 'DELETE FROM table WHERE CURRENT OF cursor name' where 'cursor name' is the value returned by 'ODB
CGetCursorName'.  It is important to point out that a positioned update using the same conversation 'x' will likely fail.  You will need to use 'ODBC CRE
ATE STATEMENT' to create a separate 'statement', then ODBC SQL and ODBC EXECUTE to execute the positioned update or delete, and 'ODBC DROP STATEMENT' to free up the statement ID.  See {\uldb Using Cursors}{\v ODBC_CURSORS}
 for more information on this topic.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBCGetData}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} function_odbcgetdata}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 107e}} {
\cs15\fs20\up6\super K{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} functions;ODBC;odbcgetdata}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {
\cs15\cf2\up6\super !} EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`functions_ODBC ')")}} ODBCGetData
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 ODBCGetData(x[,i]) - ARRAY
\par This function returns an array that consists of the columns in the result data set on the current row for the conversation identified by 'x'.  If a second (optional) parameter 'i' is included, 'i' is a 1-based column index within the result set, and 'ODBC
GetData' returns only that column's data.
\par The array itself is zero-based, so a column index must be decremented by 1 before it can be used as an index into the resulting array.  Therefore, if you wish to see column 3's data, you have to use an index of 2 into the array returned by 'ODBCGetData'.

\par NOTE:  Some ODBC drivers will not allow you to use 'ODBCGetData' more than once on the same column in the same row.  Further, these drivers will most likely not let you get any column that precedes the previous column retrieved by 'ODBCGetData
'.  To prevent this from causing problems in your program you should either get all of the desired columns sequentially
 (increasing index value) for the same row, or else use 'ODBCGetData' with only 1 parameter (thus retrieving all columns simultaneously).
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBCGetDrivers}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} function_odbcgetdrivers}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 107f}} {
\cs15\fs20\up6\super K{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} functions;ODBC;odbcgetdrivers}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {
\cs15\cf2\up6\super !} EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`functions_ODBC ')")}} ODBCGetDrivers
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 ODBCGetDrivers() - ARRAY
\par This function returns a 2-dimensional array of ODBC driver names (and additional information) that can be subsequently used in an 'ODBC CONNECT' command, prov
ided that you precede the driver name with 'DSN=' on the command line.  This can provide an alternate means of letting the user select from a list of driver names, as well as general information about the ODBC drivers that are currently installed.
\par The resulting array consists of 1 row per driver.  Column zero contains the driver name itself (that can be used in an ODBC CONNECT command).  Additional columns may or may not exist depending upon the data sources themselves, and typically consist of inf
ormation such as 'FileUsage=x' (where 'x' is the number of files open by the driver), or 'FileExtns=' followed by a list of file extensions used by the driver.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBCGetInfo}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} function_odbcgetinfo}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 107g}} {
\cs15\fs20\up6\super K{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} functions;ODBC;odbcgetinfo}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {
\cs15\cf2\up6\super !} EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`functions_ODBC ')")}} ODBCGetInfo
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 ODBCGetInfo(x,i) - VARIANT (Advanced feature)
\par This function returns a numeric or string value representing the
desired information from the ODBC driver for the conversation ID represented by 'x'.  The 'i' value is the index for the desired information.  The index values themselves are documented in the ODBC SDK for calls to the SQLGetInfo API function.  Informatio
n returned by this function is intended for advanced programmers only, who have a thorough understanding of ODBC and the ODBC SDK.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBCGetTables}} {\cs15\fs20\up6\super #{\footnote
\pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} function_odbcgettables}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 107h}} {
\cs15\fs20\up6\super K{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} functions;ODBC;odbcgettables}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {
\cs15\cf2\up6\super !} EnableButton("btn_previous");EnableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`functions_ODBC ')")}} ODBCGetTables
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 ODBCGetTables(x) - ARRAY
\par This function returns a 2-dimensional array of table names and information about each table from the ODBC driver for the conversation ID represented by 'x'.  Each table consists of a single row in the array, and the columns contain information about the t
ables.
\par Each row contains the following information, at a minimum:
\par \pard \li120\sb80\sl-240\slmult0\widctlpar\tx1080 {\ul Column}\tab {\ul Description}
\par \pard \fi-960\li1080\sb80\sl-240\slmult0\widctlpar\tqr\tx360\tx1080 \tab 0\tab TABLE QUALIFIER
\par \tab 1\tab TABLE OWNER
\par \tab 2\tab TABLE NAME
\par \tab 3\tab TABLE TYPE - one of "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY", "LOCAL TEMPORARY", "ALIAS", "SYNONYM", or an ODBC driver-specific table type.
\par \tab 4\tab REMARKS - a description of the table
\par \pard \li120\sb80\sl-240\slmult0\widctlpar
\par Other columns may also exist, and are ODBC driver-specific.
\par
\par \pard\plain \s1\li120\sb280\sa120\sl-320\slmult0\widctlpar \b\f5\fs28\cf2 \page {\cs15\fs20\up6\super ${\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super $} ODBC Sample Program}} {\cs15\fs20\up6\super #
{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super #} ODBC_SAMPLE}} {\cs15\fs20\up6\super +{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super +} 108}} {
\cs15\fs20\up6\super K{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {\cs15\cf2\up6\super K} ODBC;Sample Programs}} {\cs15\fs20\up6\super !{\footnote \pard\plain \s16\li120\sb80\sl-240\slmult0\widctlpar \f5\fs20 {
\cs15\cf2\up6\super !} EnableButton("btn_previous");DisableButton("btn_next");EnableButton("btn_up");ChangeButtonBinding("btn_up", "JumpId(`sftshell.hlp',`USING_ODBC')")}} ODBC Sample Program
\par \pard\plain \s26\li120\sl-240\slmult0\widctlpar \f5\fs20 {\f11
\par @ECHO OFF
\par ;
\par ECHO.******************************************************
\par ECHO.*           ODBC DEMO PROGRAM for SFTShell           *
\par ECHO.******************************************************
\par ECHO.
\par ECHO.******************************************************
\par ECHO.* Performing a 'generic' connect to the ODBC drivers *
\par ECHO.******************************************************
\par ECHO.
\par ;
\par ODBC CONNECT
\par if %odbc_result%==ERROR GOTO THE_END
\par let x=odbc_result
\par ? "CONNECT STRING: "++odbcconnectstring(x)
\par ECHO.
\par REPEAT
\par IF (ISYES(INPUT("Do you want to see a list of tables?")))
\par   LET y=odbcgettables(x)
\par   IF (CMD_ERROR)
\par     ODBC ERROR %x%
\par     ? ODBC_RESULT
\par     PAUSE
\par   ELSE
\par     LET n_col=NCOLS(y) - 1
\par     FOR row FROM 0 TO NROWS(y)-1
\par       LET z=getcursor()
\par       FOR col FROM 0 to n_col
\par         ?? setcursor(col * 20,z[1])
\par         ?? PrintString(y[row,col])
\par       NEXT col
\par       ECHO.
\par     NEXT row
\par   ENDIF
\par ENDIF
\par ;
\par ;* open table and allow user to optionally view fields, then list *
\par ;* each row's contents as it is fetched, using 'ODBCGetData()'    *
\par ;
\par LET dataset=LTRIM(RTRIM(INPUT("Please enter data set name: ")))
\par IF "%dataset%"=="" CONTINUE
\par odbc open %x% %dataset%
\par IF NOT %odbc_result%==ERROR GOTO OPEN_OK
\par echo.Unable to open data set %dataset%
\par ODBC ERROR %x%
\par ECHO.%ODBC_RESULT%
\par goto OPEN_TABLE
\par ;
\par ;
\par ;
\par :OPEN_OK
\par IF NOT (ISYES(INPUT("Do you want to see column info?"))) GOTO BEGIN_READ
\par ? odbcgetcolumninfo(x)
\par PAUSE
\par ;
\par ;
\par ;
\par :BEGIN_READ
\par LET iRow=1
\par odbc first %x%
\par IF (ODBC_RESULT=="ERROR")
\par   ECHO.?Unable to use 'ODBC FIRST' due to...
\par   ODBC ERROR %x%
\par   ECHO.%ODBC_RESULT%
\par   PAUSE
\par   ODBC NEXT %x%
\par ENDIF
\par ;
\par ;
\par ;
\par WHILE ODBC_RESULT!=="EOF"
\par   IF (ODBC_RESULT=="ERROR")
\par     ECHO.?Read error resulting from cursor motion
\par     ODBC ERROR %x%
\par     ECHO.%ODBC_RESULT%
\par     EXIT LOOP
\par   ENDIF
\par   ;
\par   ECHO.%(right("        "++iRow,6)++": "++odbcgetdata(x))%
\par   IF (CMD_ERROR)
\par     ECHO.?Error executing 'odbcgetdata()'
\par     ODBC ERROR %x%
\par     ECHO.%ODBC_RESULT%
\par     EXIT LOOP
\par   ENDIF
\par   ;
\par   LET iRow=iRow + 1
\par   ODBC NEXT %x%
\par WEND
\par ;
\par ECHO.* DATA COMPLETE *
\par ECHO.
\par ;
\par UNTIL ISNO(INPUT("Do you wish to view another table (Y/n)?"))
\par odbc disconnect %x%
\par :THE_END}
\par \pard\plain \li120\sb80\sl-240\slmult0\widctlpar \f5\fs20
\par }
